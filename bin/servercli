#!/usr/bin/env node

var fs = require('fs');
var program = require('commander');
var rpc = require('../jrpcClient');
var Address = require('bitcore/Address');
var Wallet = require('bitcore/Wallet');
var WalletKey = require('bitcore/WalletKey');
var Script = require('bitcore/Script');
var Transaction = require('bitcore/Transaction');
var KeyModule = require('bitcore/Key');
var coinUtil = require('bitcore/util/util');
var buffertools = require('buffertools');

var VERSION = '0.0.1';

// Empty wallet defaults
var wallet = new Wallet();
wallet.datastore.client = 'servercli';
wallet.datastore.client_version = VERSION;
wallet.datastore.network = 'testnet';

var network = undefined;

program
	.version(VERSION)
	.option('--host <hostname>', 'Remote hostname of server to contact')
	.option('--port <n>', 'Remote port of server to contact')
	.option('--wallet <file>', 'Filename of wallet')
	.option('--livenet', 'Use livenet (default: testnet)')
	.parse(process.argv);

var wallet_fn = program.wallet || 'servercli.wallet';

var rpc_opts = {
	hostname: program.host || 'localhost',
	port: program.port || 13882,
};

function list_commands()
{
	var s = "servercli command summary:\n";
	s += "init\t\tInit wallet\n";
	s += "open\t\tOpen channel\n";
	s += "setCommit CHANNEL-ID TX\tSet hex-encoded fund-commit TX (T1)\n";
	s += "setRefund CHANNEL-ID PUBKEY TX TXIN-IDX\tSet hex-encoded refund transaction\n";
	s += "commit CHANNEL-ID TX\tCommit funds to channel\n";
	s += "pay CHANNEL-ID SIGNATURE AMOUNT\tMake a payment\n";
	console.log(s);
}

function cmd_open_cb(result)
{
	if (!('channels' in wallet.datastore))
		wallet.datastore.channels = {};

	// generate K1
	var wK1 = new WalletKey({network: network});
	wK1.generate();
	var k1_obj = wK1.storeObj();
	wallet.addKey(k1_obj);

	// returned result forms basis of our local channel object
	var channelObj = result;

	// convert K2 to a channel id (bitcoin address)
	var k2_pubkeyBuf = new Buffer(channelObj.pubkey, 'hex');
	var k2_pubkey = new KeyModule.Key();
	k2_pubkey.public = k2_pubkeyBuf;
	var pubKeyHash = coinUtil.sha256ripe160(k2_pubkeyBuf);
	var addr = new Address(network.addressPubkey, pubKeyHash);
	var channelId = addr.as('base58');
	channelObj.id = channelId;

	// create multisig address for this transaction
	var script = Script.createMultisig(2, [
		wK1.privKey.public, k2_pubkey.public]);
	var msigAddrStr = wallet.addScript(script);

	channelObj.t1_output = msigAddrStr;
	channelObj.k1_addr = k1_obj.addr;

	// add channel to wallet
	wallet.datastore.channels[channelId] = channelObj;

	write_wallet();

	console.log("Payment channel " + channelId + " opened.");
	console.log("Create, sign, DO NOT BROADCAST transaction to " +
		    msigAddrStr);
}

function cmd_open()
{
	rpc.call('channel.open', [{}], rpc_opts, function(err, result) {
		if (err)
			console.log("channel.open failed: " + err.message);
		else
			cmd_open_cb(result);
	});
}

function cmd_setCommit(channelId, txHex)
{
	var channelObj = wallet.datastore.channels[channelId];
	if (!channelObj) {
		console.error("Unknown payment channel");
		process.exit(1);
	}

	var tx = new Transaction();
	tx.parse(new Buffer(txHex, 'hex'));

	if ((tx.lock_time > 0) ||
	    (tx.ins.length < 1) ||
	    (tx.outs.length < 1)) {
		console.error("Invalid commit TX");
		process.exit(1);
	}

	channelObj.t1 = txHex;

	write_wallet();

	console.log("Commit TX stored.");
}

function cmd_setRefund_cb(channelObj, refundTx, result)
{
	var sig = new Buffer(result.signature, 'hex');

	// load K2
	var k2_pubkeyBuf = new Buffer(channelObj.pubkey, 'hex');
	var k2_pubkey = new KeyModule.Key();
	k2_pubkey.public = k2_pubkeyBuf;

	// load multisig script
	var scriptHex = wallet.datastore.scripts[channelObj.t1_output];
	var scriptPubKey = new Script(new Buffer(scriptHex, 'hex'));

	// verify server signature for T2
	var sigHash = refundTx.hashForSignature(scriptPubKey, 0,
						Transaction.SIGHASH_ALL);
	if (!k2_pubkey.verifySignatureSync(sigHash, sig)) {
		console.error("Server refund TX bad signature");
		process.exit(1);
	}

	// TODO: sign it ourselves!

	console.log("Refund TX signed.  Ready to commit funds.");
}

function cmd_setRefund(channelId, pubkey, tx, txin_idx)
{
	var channelObj = wallet.datastore.channels[channelId];
	if (!channelObj) {
		console.error("Unknown payment channel");
		process.exit(1);
	}

	// reference previously stored K1
	var k1_addrStr = channelObj.k1_addr;
	if (!k1_addrStr) {
		console.error("Unknown payment channel K1 address");
		process.exit(1);
	}
	var k1_addr = new Address(k1_addrStr);
	var wK1 = new WalletKey({network: network});
	wK1.fromObj(wallet.findAddress(k1_addrStr));

	// reference previously stored T1
	var commitTx = new Transaction();
	commitTx.parse(new Buffer(channelObj.t1, 'hex'));

	// build refund transaction, T2
	var OUR_VOUT = 0;	// TODO: do not hardcode
	var refundTx = new Transaction();
	refundTx.version = 1;
	refundTx.lock_time = channelObj["timelock.prefer"];

	// T2 input 0: T1's output 0
	var emptyScript = new Script();
	var txin = new TransactionIn({
		oTxHash: coinUtil.formatHashFull(commitTx.getHash()),
		oIndex: OUR_VOUT,
		script: emptyScript.getBuffer(),
		sequence: 0xffffffff,
	});
	refundTx.ins.push(txin);

	// T2 output 0: 100% to K1
	var txout = new TransactionOut({
		value: commitTx.outs[OUR_VOUT].v,
		script: Script.createPubKeyHashOut(k1_addr.payload()),
	});
	refundTx.outs.push(txout);

	var refundTxHex = buffertools.toHex(refundTx.serialize());

	channelObj.refundTx = refundTxHex;
	write_wallet();

	rpc.call('channel.setRefund', [{
		"channel.id": channelId,
		pubkey: buffertools.toHex(wK1.privKey.public),
		tx: refundTxHex,
		txInIdx: 0,
	}], rpc_opts, function(err, result) {
		if (err)
			console.log("channel.setRefund failed: " + err.message);
		else
			cmd_setRefund_cb(channelObj, refundTx, result);
	});
}

function cmd_commit_cb(channelObj, result)
{
	channelObj.commit = true;
	write_wallet();

	console.log("Payment channel " + channelObj.id + " funds committed.");
}

function cmd_commit(channelId, firstPaymentVal)
{
	var channelObj = wallet.datastore.channels[channelId];
	if (!channelObj) {
		console.error("Unknown payment channel");
		process.exit(1);
	}

	// TODO: build modified T3 containing first payment

	rpc.call('channel.commit', [{
		"channel.id": channelId,
		tx: channgeObj.t1,
	}], rpc_opts, function(err, result) {
		if (err)
			console.log("channel.commit failed: " + err.message);
		else
			cmd_commit_cb(channelObj, result);
	});
}

function cmd_pay(channelId, amount)
{
	// FIXME

	rpc.call('channel.pay', [{
		"channel.id": channelId,
		signature: signature,
		amount: amount,
		}], rpc_opts, function(err, result) {
		if (err)
			console.log("channel.pay failed: " + err.message);
		else
			console.dir(result);
	});
}

function set_network(netname)
{
	wallet.setNetwork(netname);
	network = wallet.network;
}

function write_wallet()
{
	try {
		wallet.writeSync(wallet_fn, process.env.SERVERCLI);
	} catch(e) {
		console.error("Failed to write wallet: " + e);
		process.exit(1);
	}
}

function read_wallet()
{
	try {
		wallet.readSync(wallet_fn, process.env.SERVERCLI);
		set_network(wallet.datastore.network);
	} catch(e) {
		console.error("Failed to read wallet: " + e);
		process.exit(1);
	}
}

function cmd_init()
{
	if (program.livenet)
		set_network('livenet');
	else
		set_network('testnet');

	if (fs.existsSync(wallet_fn))
		read_wallet();

	write_wallet();
}

function dump_wallet()
{
	console.dir(wallet.datastore);
}

function main()
{
	if (!process.env.SERVERCLI) {
		console.error("SERVERCLI passphrase must be set.");
		return;
	}
	if (program.args.length == 0) {
		console.error("No command specified.");
		list_commands();
		return;
	}

	var cmd = program.args[0];

	if (cmd != "init")
		read_wallet();
	
	switch (cmd) {

	default:
		console.error("Unknown command", cmd);
		// fall through

	case "init":
		cmd_init();
		break;

	case "dump":
		dump_wallet();
		break;

	case "open":
		cmd_open();
		break;

	case "setCommit":
		if (program.args.length != 3)
			throw new Error("Usage: setCommit channel-id tx");
		cmd_setCommit(program.args[1], program.args[2]);
		break;

	case "setRefund":
		if (program.args.length != 5)
			throw new Error("Usage: setRefund channel-id public tx txin_idx");
		cmd_setRefund(program.args[1], program.args[2],
			      program.args[3], program.args[4]);
		break;

	case "commit":
		if (program.args.length != 3)
			throw new Error("Usage: commit channel-id first-payment-amount");
		cmd_commit(program.args[1], program.args[2]);
		break;

	case "pay":
		if (program.args.length != 3)
			throw new Error("Usage: pay channel-id amount");
		cmd_pay(program.args[1], program.args[2]);
		break;

	case "help":
		list_commands();
		return;
	}
}

main();


